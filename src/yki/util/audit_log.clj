(ns yki.util.audit-log
  (:require
    [clj-json-patch.core :as patch]
    [clj-json-patch.util :refer [apply-patch get-patch-value]]
    [clojure.string :as str]
    [clojure.tools.logging :as log]
    [clojure.walk :refer [stringify-keys]]
    [jsonista.core :as json]
    [yki.util.log-util :as log-util])
  (:import [java.net InetAddress]
           [org.ietf.jgss Oid]
           [com.google.gson JsonArray JsonParser]
           [com.fasterxml.jackson.datatype.joda JodaModule]
           [fi.vm.sade.auditlog Audit ApplicationType Logger Operation User Target$Builder Changes Changes$Builder]))

(def mapper
  (json/object-mapper
    {:modules [(JodaModule.)]}))

(def update-op "update")
(def create-op "create")
(def delete-op "delete")
(def cancel-op "cancel")
(def organizer "organizer")
(def payment "payment")
(def evaluation-payment "evaluation-payment")
(def registration "registration")
(def registration-init "registration-init")
(def exam-session "exam-session")
(def exam-date "exam-date")
(def quarantine "quarantine")
(def quarantine-review "quarantine-review")

(defonce ^JsonParser jsonParser (JsonParser.))

(defonce ^Logger logger-proxy
         (reify Logger
           (log [_ msg]
             (log/info msg))))

(defn op ^Operation [operation]
  (reify Operation
    (name [_]
      operation)))

(defn- ->json-string ^String [value]
  (json/write-value-as-string value mapper))

(defonce ^:private ^Audit virkailija-logger (Audit. logger-proxy "yki" ApplicationType/VIRKAILIJA))

(defonce ^:private ^Audit oppija-logger (Audit. logger-proxy "yki" ApplicationType/OPPIJA))

(defn- format-json-path [^String path]
  (-> (subs path 1)
      (str/replace #"/" ".")))

(defn- ->json-element [value]
  (->> value
       (->json-string)
       (.parse jsonParser)
       (.getAsJsonObject)))

(defn- process-patch-array [value patch-array]
  (try
    (loop [current-value     value
           patches           patch-array
           processed-patches []]
      (if (seq patches)
        (let [current-patch  (first patches)
              {op             "op"
               path           "path"
               new-path-value "value"} current-patch
              old-path-value (and
                               (#{"replace" "remove"} op)
                               (get-patch-value current-value (get current-patch "path")))]
          (recur
            (apply-patch current-value current-patch)
            (rest patches)
            (conj processed-patches {"newValue" new-path-value
                                     "oldValue" old-path-value
                                     "op"       op
                                     "path"     path})))
        processed-patches))
    (catch Exception e
      (log-util/error e "Post-processing patch array failed. Returning instead original patch array for audit logging: " patch-array)
      patch-array)))

(defn- update->json-array
  "Given two objects, represents their diff as an JsonArray
  consisting of JSON Patch operations.

  Tries to first calculate the diff using the clj-json-patch library,
  as the patches generated by it seem to be of better quality than those
  generated by other alternatives tried.

  However, certain inputs (eg. arrays of maps) seem to trigger
  seemingly exponential slowdown for the diff algorithm used by clj-json-patch.

  If calculating the diff takes more than 1s, the evaluation is interrupted and
  we fall back to the implementation from auditlogger.
  The JSON patches generated by the fallback implementation are of poorer quality
  but the algorithm seems to have more stable performance."
  [old new]
  (let [old         (stringify-keys old)
        new         (stringify-keys new)
        timeout-ms  1000
        timeout-val ::timeout
        diff-fut    (future (patch/diff old new))
        res         (deref diff-fut timeout-ms timeout-val)]
    (if (= res timeout-val)
      (do
        (log-util/error "Timed out calculating diff for changes!")
        (future-cancel diff-fut)
        (.asJsonArray (Changes/updatedDto (->json-element new) (->json-element old))))
      (->> res
           (process-patch-array old)
           (mapv #(update % "path" format-json-path))
           (->json-string)
           (.parse jsonParser)
           (.getAsJsonArray)))))

(defn- create-changes ^JsonArray [change]
  (case (:type change)
    "update" (let [old (:old change)
                   new (:new change)]
               (update->json-array old new))
    "delete" (.asJsonArray (.build (Changes$Builder.)))
    "cancel" (.asJsonArray (.build (Changes$Builder.)))
    "create" (let [new (->json-element (:new change))]
               (.asJsonArray (Changes/addedDto new)))))

(defn- oid-or-nil [^String oid]
  (when oid
    (Oid. oid)))

(defn log
  [{:keys [request target-kv change]}]
  (try
    (let [inet-address (InetAddress/getLocalHost)
          session      (:session request)
          oid          (get-in session [:identity :oid])
          user-agent   ((:headers request) "user-agent")
          user         (User. (oid-or-nil oid) inet-address (:yki-session-id session) user-agent)
          op           (op (:type change))
          target       (-> (Target$Builder.)
                           (.setField (:k target-kv) (str (:v target-kv)))
                           (.build))
          changes      (create-changes change)]
      (.log virkailija-logger user op target changes))
    (catch Exception e
      (log-util/error e "Virkailija audit logging failed for data:" change))))

(defn log-participant
  [{:keys [request target-kv change oid]}]
  (try
    (let [inet-address (InetAddress/getLocalHost)
          session      (:session request)
          oid          (or oid (get-in session [:identity :oid]))
          user-agent   ((:headers request) "user-agent")
          user         (User. (oid-or-nil oid) inet-address (:yki-session-id session) user-agent)
          op           (op (:type change))
          target       (-> (Target$Builder.)
                           (.setField (:k target-kv) (str (:v target-kv)))
                           (.build))
          changes      (create-changes change)]
      (.log oppija-logger user op target changes))
    (catch Exception e
      (log-util/error e "Participant audit logging failed for data:" change))))
